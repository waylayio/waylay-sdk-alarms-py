# coding: utf-8
"""Waylay Alarms query parameters.

This code was generated from the OpenAPI documentation of 'Waylay Alarms'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

from __future__ import annotations  # for Python 3.7â€“3.9
import io
import warnings

from pydantic import (
    BaseModel,
    validate_call,
    Field,
    StrictFloat,
    StrictStr,
    StrictInt,
    ConfigDict,
    SerializationInfo,
    model_serializer,
)
from pydantic_core import from_json
from typing import Dict, List, Optional, Tuple, Union, Any, Callable
from typing_extensions import (
    Self,  # >=3.11
)

from pydantic import Field
from typing_extensions import Annotated
from pydantic import StrictInt, StrictStr, field_validator

from typing import Dict, List, Optional

from ..models.alarm_entity import AlarmEntity
from ..models.alarm_severity import AlarmSeverity
from ..models.alarm_status import AlarmStatus
from ..models.alarm_update import AlarmUpdate
from ..models.alarms_query_result import AlarmsQueryResult
from ..models.create_alarm import CreateAlarm
from ..models.list_additional_query_params_parameter_value import (
    ListAdditionalQueryParamsParameterValue,
)


def _create_query_alias_for(field_name: str) -> str:
    return field_name


class CreateQuery(BaseModel):
    """Model for `create` query parameters."""

    model_config = ConfigDict(
        validate_assignment=True,
        protected_namespaces=(),
        extra="allow",
        alias_generator=_create_query_alias_for,
        populate_by_name=True,
    )

    @model_serializer(mode="wrap")
    def serializer(
        self, handler: Callable, info: SerializationInfo
    ) -> Dict[StrictStr, Any]:
        """The default serializer of the model.

        * Excludes `None` fields that were not set at model initialization.
        """
        model_dict = handler(self, info)
        return {
            k: v
            for k, v in model_dict.items()
            if v is not None or k in self.model_fields_set
        }

    def to_dict(self) -> dict[str, Any]:
        """Convert the CreateQuery instance to dict."""
        return self.model_dump(by_alias=True, exclude_unset=True, exclude_none=True)

    def to_json(self) -> str:
        """Convert the CreateQuery instance to a JSON-encoded string."""
        return self.model_dump_json(
            by_alias=True, exclude_unset=True, exclude_none=True
        )

    @classmethod
    def from_dict(cls, obj: dict) -> Self:
        """Create a CreateQuery instance from a dict."""
        return cls.model_validate(obj)

    @classmethod
    def from_json(cls, json_data: str | bytes | bytearray) -> Self:
        """Create a CreateQuery instance from a JSON-encoded string."""
        return cls.model_validate_json(json_data)


def _delete_query_alias_for(field_name: str) -> str:
    return field_name


class DeleteQuery(BaseModel):
    """Model for `delete` query parameters."""

    model_config = ConfigDict(
        validate_assignment=True,
        protected_namespaces=(),
        extra="allow",
        alias_generator=_delete_query_alias_for,
        populate_by_name=True,
    )

    @model_serializer(mode="wrap")
    def serializer(
        self, handler: Callable, info: SerializationInfo
    ) -> Dict[StrictStr, Any]:
        """The default serializer of the model.

        * Excludes `None` fields that were not set at model initialization.
        """
        model_dict = handler(self, info)
        return {
            k: v
            for k, v in model_dict.items()
            if v is not None or k in self.model_fields_set
        }

    def to_dict(self) -> dict[str, Any]:
        """Convert the DeleteQuery instance to dict."""
        return self.model_dump(by_alias=True, exclude_unset=True, exclude_none=True)

    def to_json(self) -> str:
        """Convert the DeleteQuery instance to a JSON-encoded string."""
        return self.model_dump_json(
            by_alias=True, exclude_unset=True, exclude_none=True
        )

    @classmethod
    def from_dict(cls, obj: dict) -> Self:
        """Create a DeleteQuery instance from a dict."""
        return cls.model_validate(obj)

    @classmethod
    def from_json(cls, json_data: str | bytes | bytearray) -> Self:
        """Create a DeleteQuery instance from a JSON-encoded string."""
        return cls.model_validate_json(json_data)


def _get_query_alias_for(field_name: str) -> str:
    return field_name


class GetQuery(BaseModel):
    """Model for `get` query parameters."""

    model_config = ConfigDict(
        validate_assignment=True,
        protected_namespaces=(),
        extra="allow",
        alias_generator=_get_query_alias_for,
        populate_by_name=True,
    )

    @model_serializer(mode="wrap")
    def serializer(
        self, handler: Callable, info: SerializationInfo
    ) -> Dict[StrictStr, Any]:
        """The default serializer of the model.

        * Excludes `None` fields that were not set at model initialization.
        """
        model_dict = handler(self, info)
        return {
            k: v
            for k, v in model_dict.items()
            if v is not None or k in self.model_fields_set
        }

    def to_dict(self) -> dict[str, Any]:
        """Convert the GetQuery instance to dict."""
        return self.model_dump(by_alias=True, exclude_unset=True, exclude_none=True)

    def to_json(self) -> str:
        """Convert the GetQuery instance to a JSON-encoded string."""
        return self.model_dump_json(
            by_alias=True, exclude_unset=True, exclude_none=True
        )

    @classmethod
    def from_dict(cls, obj: dict) -> Self:
        """Create a GetQuery instance from a dict."""
        return cls.model_validate(obj)

    @classmethod
    def from_json(cls, json_data: str | bytes | bytearray) -> Self:
        """Create a GetQuery instance from a JSON-encoded string."""
        return cls.model_validate_json(json_data)


def _list_query_alias_for(field_name: str) -> str:
    if field_name == "type":
        return "type"
    if field_name == "status":
        return "status"
    if field_name == "severity":
        return "severity"
    if field_name == "source":
        return "source"
    if field_name == "date_from":
        return "dateFrom"
    if field_name == "date_to":
        return "dateTo"
    if field_name == "var_from":
        return "from"
    if field_name == "to":
        return "to"
    if field_name == "creation_time_from":
        return "creationTimeFrom"
    if field_name == "creation_time_to":
        return "creationTimeTo"
    if field_name == "last_updated_from":
        return "lastUpdatedFrom"
    if field_name == "last_updated_to":
        return "lastUpdatedTo"
    if field_name == "last_triggered_from":
        return "lastTriggeredFrom"
    if field_name == "last_triggered_to":
        return "lastTriggeredTo"
    if field_name == "sort":
        return "sort"
    if field_name == "order":
        return "order"
    if field_name == "page":
        return "page"
    if field_name == "size":
        return "size"
    if field_name == "additional_query_params":
        return "additionalQueryParams"
    return field_name


class ListQuery(BaseModel):
    """Model for `list` query parameters."""

    type: Annotated[
        List[StrictStr] | None, Field(description="Filter on one or more alarm types.")
    ] = None
    status: Annotated[
        List[AlarmStatus] | None,
        Field(description="Filter on one or more alarm statuses."),
    ] = None
    severity: Annotated[
        List[AlarmSeverity] | None,
        Field(description="Filter on one or more alarm severities."),
    ] = None
    source: Annotated[
        List[StrictStr] | None,
        Field(
            description="Filter on one or more source ids.  At least one source id is mandatory in combination with `Accept: application/vnd.waylay.alarms.timeseries+json`"
        ),
    ] = None
    date_from: Annotated[
        StrictInt | None,
        Field(description="Filter on alarm timestamp (equal or above)."),
    ] = None
    date_to: Annotated[
        StrictInt | None,
        Field(description="Filter on alarm timestamp (equal or below)."),
    ] = None
    var_from: Annotated[
        StrictInt | None,
        Field(
            description="Only applicable in combination with `Accept: application/vnd.waylay.alarms.timeseries+json`  Limits the timestamp of the Alarm Audit Records to be >= `from`"
        ),
    ] = None
    to: Annotated[
        StrictInt | None,
        Field(
            description="Only applicable in combination with `Accept: application/vnd.waylay.alarms.timeseries+json`  Limits the timestamp of the Alarm Audit Records to be <= `to`"
        ),
    ] = None
    creation_time_from: Annotated[
        StrictInt | None,
        Field(description="Filter on alarm creationTime (equal or above)."),
    ] = None
    creation_time_to: Annotated[
        StrictInt | None,
        Field(description="Filter on alarm creationTime (equal or below)."),
    ] = None
    last_updated_from: Annotated[
        StrictInt | None,
        Field(description="Filter on alarm lastUpdateTime (equal or above)."),
    ] = None
    last_updated_to: Annotated[
        StrictInt | None,
        Field(description="Filter on alarm lastUpdateTime (equal or below)."),
    ] = None
    last_triggered_from: Annotated[
        StrictInt | None,
        Field(description="Filter on alarm lastTriggeredTime (equal or above)."),
    ] = None
    last_triggered_to: Annotated[
        StrictInt | None,
        Field(description="Filter on alarm lastTriggeredTime (equal or below)."),
    ] = None
    sort: Annotated[
        StrictStr | None,
        Field(
            description="(Pagination) field used to sort the alarms  Ignored in combination with `Accept: application/vnd.waylay.alarms.timeseries+json`"
        ),
    ] = None
    order: Annotated[
        StrictStr | None,
        Field(
            description="(Pagination) sort order  Ignored in combination with `Accept: application/vnd.waylay.alarms.timeseries+json`"
        ),
    ] = None
    page: Annotated[
        StrictInt | None,
        Field(
            description="(Pagination) page Number   Ignored in combination with `Accept: application/vnd.waylay.alarms.timeseries+json`"
        ),
    ] = None
    size: Annotated[
        StrictInt | None,
        Field(
            description="(Pagination) size of a page  Ignored in combination with `Accept: application/vnd.waylay.alarms.timeseries+json`"
        ),
    ] = None
    additional_query_params: Annotated[
        Dict[str, ListAdditionalQueryParamsParameterValue] | None,
        Field(
            description="To query the alarms based on the value of an additional property of the alarm,  you can add the key of the additional property as query parameter  with value the value you expect the alarm to have."
        ),
    ] = None

    model_config = ConfigDict(
        validate_assignment=True,
        protected_namespaces=(),
        extra="allow",
        alias_generator=_list_query_alias_for,
        populate_by_name=True,
    )

    @model_serializer(mode="wrap")
    def serializer(
        self, handler: Callable, info: SerializationInfo
    ) -> Dict[StrictStr, Any]:
        """The default serializer of the model.

        * Excludes `None` fields that were not set at model initialization.
        """
        model_dict = handler(self, info)
        return {
            k: v
            for k, v in model_dict.items()
            if v is not None or k in self.model_fields_set
        }

    def to_dict(self) -> dict[str, Any]:
        """Convert the ListQuery instance to dict."""
        return self.model_dump(by_alias=True, exclude_unset=True, exclude_none=True)

    def to_json(self) -> str:
        """Convert the ListQuery instance to a JSON-encoded string."""
        return self.model_dump_json(
            by_alias=True, exclude_unset=True, exclude_none=True
        )

    @classmethod
    def from_dict(cls, obj: dict) -> Self:
        """Create a ListQuery instance from a dict."""
        return cls.model_validate(obj)

    @classmethod
    def from_json(cls, json_data: str | bytes | bytearray) -> Self:
        """Create a ListQuery instance from a JSON-encoded string."""
        return cls.model_validate_json(json_data)


def _update_query_alias_for(field_name: str) -> str:
    return field_name


class UpdateQuery(BaseModel):
    """Model for `update` query parameters."""

    model_config = ConfigDict(
        validate_assignment=True,
        protected_namespaces=(),
        extra="allow",
        alias_generator=_update_query_alias_for,
        populate_by_name=True,
    )

    @model_serializer(mode="wrap")
    def serializer(
        self, handler: Callable, info: SerializationInfo
    ) -> Dict[StrictStr, Any]:
        """The default serializer of the model.

        * Excludes `None` fields that were not set at model initialization.
        """
        model_dict = handler(self, info)
        return {
            k: v
            for k, v in model_dict.items()
            if v is not None or k in self.model_fields_set
        }

    def to_dict(self) -> dict[str, Any]:
        """Convert the UpdateQuery instance to dict."""
        return self.model_dump(by_alias=True, exclude_unset=True, exclude_none=True)

    def to_json(self) -> str:
        """Convert the UpdateQuery instance to a JSON-encoded string."""
        return self.model_dump_json(
            by_alias=True, exclude_unset=True, exclude_none=True
        )

    @classmethod
    def from_dict(cls, obj: dict) -> Self:
        """Create a UpdateQuery instance from a dict."""
        return cls.model_validate(obj)

    @classmethod
    def from_json(cls, json_data: str | bytes | bytearray) -> Self:
        """Create a UpdateQuery instance from a JSON-encoded string."""
        return cls.model_validate_json(json_data)
